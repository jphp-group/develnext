package org.develnext.jphp.ext.javafx.support;


import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventHandler;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Paint;

public class ImageViewEx extends Canvas {
    protected Image image;

    protected Image originImage;
    protected Image hoverImage;
    protected Image clickImage;

    protected boolean autoSize;
    protected boolean stretch;
    protected boolean centred;
    protected boolean proportional;

    protected boolean mosaic;
    protected double mosaicGap = 0;

    private boolean _entered = false;

    protected Paint background = null;

    public ImageViewEx() {
        super();

        widthProperty().addListener(new ChangeListener<Number>() {
            @Override
            public void changed(ObservableValue<? extends Number> observableValue, Number number, Number t1) {
                update();
            }
        });

        heightProperty().addListener(new ChangeListener<Number>() {
            @Override
            public void changed(ObservableValue<? extends Number> observableValue, Number number, Number t1) {
                update();
            }
        });

        addEventFilter(MouseEvent.MOUSE_ENTERED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                ImageViewEx.this._entered = true;
                if (hoverImage != null) {
                    ImageViewEx.this.image = hoverImage;
                    update();
                }
            }
        });

        addEventFilter(MouseEvent.MOUSE_EXITED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                ImageViewEx.this.image = originImage;
                ImageViewEx.this._entered = false;
                update();
            }
        });

        addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                if (clickImage != null) {
                    ImageViewEx.this.image = clickImage;
                    update();
                }
            }
        });

        addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                if (clickImage != null) {
                    ImageViewEx.this.image = clickImage;
                    update();
                }
            }
        });

        addEventFilter(MouseEvent.MOUSE_RELEASED, new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent mouseEvent) {
                if (_entered && hoverImage != null) {
                    ImageViewEx.this.image = hoverImage;
                    update();
                } else if (image != originImage) {
                    ImageViewEx.this.image = originImage;
                    update();
                }
            }
        });
    }

    public Image getImage() {
        return this.originImage;
    }

    public void setImage(Image image) {
        this.image = image;
        this.originImage = image;
        update();
    }

    public Image getHoverImage() {
        return hoverImage;
    }

    public void setHoverImage(Image hoverImage) {
        this.hoverImage = hoverImage;
    }

    public Image getClickImage() {
        return clickImage;
    }

    public void setClickImage(Image clickImage) {
        this.clickImage = clickImage;
    }

    public boolean isAutoSize() {
        return autoSize;
    }

    public void setAutoSize(boolean autoSize) {
        this.autoSize = autoSize;
        update();
    }

    public boolean isStretch() {
        return stretch;
    }

    public void setStretch(boolean stretch) {
        this.stretch = stretch;
        update();
    }

    public boolean isCentred() {
        return centred;
    }

    public void setCentred(boolean centred) {
        this.centred = centred;
        update();
    }

    public boolean isMosaic() {
        return mosaic;
    }

    public void setMosaic(boolean mosaic) {
        this.mosaic = mosaic;
        update();
    }

    public double getMosaicGap() {
        return mosaicGap;
    }

    public void setMosaicGap(double mosaicGap) {
        this.mosaicGap = mosaicGap;
        update();
    }

    public boolean isProportional() {
        return proportional;
    }

    public void setProportional(boolean proportional) {
        this.proportional = proportional;
        update();
    }

    public Paint getBackground() {
        return background;
    }

    public void setBackground(Paint background) {
        this.background = background;
        update();
    }

    @Override
    public double prefWidth(double height) {
        return getWidth();
    }

    @Override
    public double prefHeight(double width) {
        return getHeight();
    }

    @Override
     public boolean isResizable() {
        return !autoSize;
    }

    @Override
    public void resize(double v, double v1) {
        setWidth(v);
        setHeight(v1);
    }

    protected void update() {
        if (autoSize) {
            setWidth(image == null ? 0 : image.getWidth());
            setHeight(image == null ? 0 : image.getHeight());
        }

        GraphicsContext g2 = this.getGraphicsContext2D();

        g2.clearRect(0, 0, getWidth(), getHeight());

        if (background != null) {
            g2.setFill(background);
            g2.fillRect(0, 0, getWidth(), getHeight());
        }

        if (image == null) {
            return;
        }

        double x = 0, y = 0, w = image.getWidth(), h = image.getHeight();

        if (isMosaic()) {
            int horCount = (int) Math.ceil(getWidth() /  w + mosaicGap);
            int verCount = (int) Math.ceil(getHeight() /  h + mosaicGap);

            for (int i = 0; i < verCount; i++) {
                for (int j = 0; j < horCount; j++) {
                    g2.drawImage(image, j * w + (j * mosaicGap), i * h + (i * mosaicGap), w, h);
                }
            }
        } else {
            if (isStretch()) {
                if (isProportional()) {
                    double ratio = Math.min(getWidth() / w, getHeight() / h);
                    w = (int) (w * ratio);
                    h = (int) (h * ratio);
                } else {
                    w = getWidth();
                    h = getHeight();
                }
            }

            if (isCentred()) {
                x = getWidth() / 2 - w / 2;
                y = getHeight() / 2 - h / 2;
            }

            g2.drawImage(image, x, y, w, h);
        }
    }
}
